# dz3
## Карпова Софья Саналовна - БПИ218 - Вариант 34

Разработать программу, определяющую корень уравнения x<sup>4</sup> + 2x<sup>3</sup> − x − 1 = 0 методом половинного деления с точностью = 0,000001 в диапазоне [0;1]. Если диапазон некорректен, то подобрать корректный диапазон.

### 8 баллов

Сначала я написала решение задачи на языке Си ([8/main.c](main.c)). Входные данные для программы - два числа, задающие диапазон, на котором ищутся корни функции. Затем, чтобы получить ассемблерный код, я воспользовалась следующей командой:

```sh
$gcc -O0 -masm=intel -Wall -fno-asynchronous-unwind-tables -fcf-protection=none -S ./main.c -o ./main.asm
```

Код, составленный компилятором можно посмотреть здесь: [8/noopt.asm](noopt.asm).

Полученный в результате компиляции ассемблерный код я разделила на два модуля, в одном из которых находится функция main ([8/main.asm](main.asm)), а во втором все остальные функции ([8/funcs.asm](funcs.asm)). В программу были добавлены комментарии, поясняющие эквивалентное использование переменных в программе на Си. Использование памяти стека было сведено к минимуму.
Из отредактированного ассемблерного кода я получила исполняемый файл с помощью утилиты Make ([8/Makefile](Makefile)). Makefile выглядит следующим образом:
```sh
idz3: main.o funcs.o
	gcc -o idz3 main.o funcs.o
main.o: main.asm
	as --gstabs -o main.o main.asm
funcs.o: funcs.asm
	as --gstabs -o funcs.o funcs.asm
```
Чтобы собрать многомодульную программу достаточно просто написать в консоли 'make':
```sh
$make
```
Исполняемый файл будет называться 'idz3', а запустить его можно двумя способами: либо с ключом компиляции '-c', либо '-f' (опции генерации случайных чисел не предусматривается по словам семинариста). Первый - запустить с вводом через консоль:
```sh
$./idz3 -c
1 0
```
Второй - файловый ввод-вывод:
```sh
$./idz3 -f input.txt output.txt
```
Имена файлов должны передаваться через пробел и быть заранее созданы, первый файл используется для ввода, второй - для вывода.
Программа корректно работает на всех тестах. Выходные данные совпадают для ассемблерного и Си кода ([8/tests.txt](tests.txt)).

После проведенных тестов на время исполнения Си и асеемблерного кода можно сделать вывод, что их разница в производительности крайне незначительна, так как даже на достаточно больших входных данных время работы не отличается. Время работы программ можно посмотреть в файле с тестами ([8/tests.txt](tests.txt)).
